# Docker Compose file Reference (https://docs.docker.com/compose/compose-file/)
# Compose meanwhile always uses the most recent schema to validate the Compose file, regardless of the version field.

# NOTE: An existing .env file will be loaded implicitly by docker-compose to adjust the environment of the docker-compose
# command itself, whereas defining an "env_file: ..." inside the yaml will take environment variables from the file
# and inject them into the container (i.e. they cannot be used for variables *inside* your yaml)
# Source: https://stackoverflow.com/a/58048994/4292075
# make sure all vars in environment: block below (right side) are defined in .env so they can be expanded
# TIP: 'docker-compose config' will show the resolved application config

# Define services. A Service is an abstract definition of a computing resource within an application
# which can be scaled/replaced independently of other components.
services:

  # App Backend (aka API) Service
  angkor-api:
    image: ${DOCKER_USER}/${APPID}-api:${API_VERSION}
    container_name: angkor-api
    # env_file: "./.env" # KEEP DISABLED, see top level comment
    environment:

      ## Since we don't use docker-compose in dev, PROD Profile applies
      SPRING_PROFILES_ACTIVE: prod

      ## JDBC config
      SPRING_DATASOURCE_URL: ${DB_URL} # resolved from .env
      SPRING_DATASOURCE_USERNAME: ${DB_USERNAME}
      SPRING_DATASOURCE_PASSWORD: ${DB_PASSWORD} 

      ## OAuth2 config
      SPRING_SECURITY_OAUTH2_CLIENT_PROVIDER_COGNITO_ISSUER_URI: ${OAUTH2_ISSUER_URI}
      SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_COGNITO_CLIENT_SECRET: ${OAUTH2_CLIENT_SECRET} 
      SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_COGNITO_CLIENT_ID: ${OAUTH2_CLIENT_ID}
      SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_COGNITO_CLIENT_NAME: ${OAUTH2_CLIENT_NAME}
      SPRING_SECURITY_OAUTH2_CLIENT_REGISTRATION_COGNITO_REDIRECT_URI_TEMPLATE: https://${CERTBOT_DOMAIN_NAME}/login/oauth2/code/cognito

      ## Kafka config (Your configuration options can contain environment variables.)
      SPRING_KAFKA_BOOTSTRAP_SERVERS: ${KAFKA_BROKERS}
      # you can also use variables within values, but beware of quote escape issues
      SPRING_KAFKA_PROPERTIES_SASL_JAAS_CONFIG: "org.apache.kafka.common.security.scram.ScramLoginModule required username=\"${KAFKA_SASL_USERNAME}\" password=\"${KAFKA_SASL_PASSWORD}\";"


      # Profile / Flyway config
      # WARNING uncomment the following two vars to enable clean can clear db before start
      ## SPRING_FLYWAY_CLEAN_DISABLED: "false"
      ## SPRING_PROFILES_ACTIVE: "prod,clean"

      # Spring Application Config (Prefix APP_
      APP_ADMIN_MAIL: ${APP_ADMIN_MAIL}
      APP_API_TOKEN: ${APP_API_TOKEN} # from HCP Secrets
      APP_EXTERNAL_BASE_URL: ${APP_EXTERNAL_BASE_URL}
      # TODO switch to confluent and re-enable, in disabled mode only log entries will be shown (dry run mode)
      APP_KAFKA_ENABLED: "false"
      APP_KAFKA_TOPIC_PREFIX: ${APP_KAFKA_TOPIC_PREFIX}
      # used by prometheus, generated by infra project
      APP_METRICS_BASIC_AUTH_PASSWORD: ${APP_API_TOKEN_METRICS}
      APP_PHOTOS_FEED_URL: ${APP_PHOTOS_FEED_URL}
      APP_TOURS_API_BASE_URL: ${APP_TOURS_API_BASE_URL}
      APP_TOURS_API_USER_ID: ${APP_TOURS_API_USER_ID}

      # Other misc config
      LOGGING_LEVEL_ROOT: INFO
      # Reduce Memory: https://stackoverflow.com/questions/44491257/how-to-reduce-spring-boot-memory-usage
      # With -XX:+UseSerialGC This will perform garbage collection inline with the thread allocating
      # the heap memory instead of a dedicated GC thread(s)
      JAVA_OPTS: -XX:+UseSerialGC
      # Check actual values: java -XX:+PrintFlagsFinal -version |grep -Ei "maxheapsize|maxram"
    ports:
      - "8080:8080" # Forward the exposed port 8080 on the container to port 8080 on the host machine
    restart: always
    volumes:
      - ./upload:/tmp/upload
    networks:
      - angkor-network

  ## App health monitoring service
  healthbells:
    image: ghcr.io/tillkuhn/angkor-tools:main
    container_name: healthbells
    env_file: "./.env"
    entrypoint: /tools/healthbells # overwrite since it's a shared tool image
    environment:
      HEALTHBELLS_PORT: "8091"
      HEALTHBELLS_INTERVAL: "300s"
      # CAUTION: for actuator, use a "cheap" endpoint such as /actuator/health/ping that doesn't claim a db connection,
      # which alows the hikari cp pool to scale down to 0, thus saving valuable neodb hours (result: {"status":"UP"})
      HEALTHBELLS_URLS: "https://${CERTBOT_DOMAIN_NAME}/actuator/health/ping,https://${CERTBOT_DOMAIN_NAME}/alive,https://${CERTBOT_DOMAIN_NAME}/imagine/health"
    ports:
      - "8091:8091"
    restart: always
    deploy:
      resources:
        limits:
          memory:  10m
    networks:
      - angkor-network

  ## App image and file processing service
  imagine:
    image: ghcr.io/tillkuhn/angkor-tools:main
    container_name: imagine
    env_file: "./.env"
    entrypoint: /tools/imagine # overwrite since it's a shared tool image
    environment:
      IMAGINE_KAFKA_SUPPORT: "false"
      IMAGINE_PORT: "8090"
      IMAGINE_S3BUCKET: "${BUCKET_NAME}"
      IMAGINE_S3PREFIX: "imagine/" # todo this is already new default in recent version
      IMAGINE_DUMPDIR: "/tmp" # use /tmp root in container, no volume mount necessary
      IMAGINE_FORCE_GC: "true" # call freeMemory / force gc after expensive operations
      IMAGINE_API_TOKEN_METRICS: "${APP_API_TOKEN_METRICS}"
    ports:
      - "8090:8090"
    restart: always
    # required  https://github.com/docker/compose/pull/5684 to be used with version 3
    deploy:
      resources:
        limits:
          memory: 80m
    mem_reservation: 10m
    networks:
      - angkor-network

  ## App frontend service
  angkor-ui:
    image: ${DOCKER_USER}/${APPID}-ui:${UI_VERSION}
    container_name: angkor-ui
    env_file: "./.env"
    # make sure vars are defined in .env which is loaded implicitly
    # docker-compose config will show the resolved application config
    environment:
      SERVER_NAMES: "${SERVER_NAMES}"
      SERVER_NAME_PATTERN: "${CERTBOT_DOMAIN_NAME}"
      MAPBOX_ACCESS_TOKEN: "${MAPBOX_ACCESS_TOKEN}"
      IMPRINT_URL: "${IMPRINT_URL}"
      API_HOST: "angkor-api" # for nginx proxy_pass
      API_PORT: "8080" #  make sure it matches the part of the api service definition above
      HEALTHBELLS_HOST: "healthbells" # for nginx proxy_pass
      HEALTHBELLS_PORT: "8091" # make sure it matches the part of the healthbells service definition below
      IMAGINE_HOST: "imagine" # for nginx proxy_pass
      IMAGINE_PORT: "8090" # make sure it matches the part of the healthbells service definition below
    ports:
      # Either specify both ports (HOST:CONTAINER), or just the container port (an ephemeral host port is chosen).
      - "80:80"
      - "443:443"
    restart: always
    volumes:
      - /etc/letsencrypt/live/${CERTBOT_DOMAIN_NAME}/fullchain.pem:/etc/ssl/certs/fullchain.pem
      - /etc/letsencrypt/live/${CERTBOT_DOMAIN_NAME}/privkey.pem:/etc/ssl/certs/privkey.pem
      - /etc/ssl/certs/dhparam.pem:/etc/ssl/certs/dhparam.pem
      #  "." expand to the dir, where the YAML (docker-compose) file is and PWD is your current dir
      - ./docs:/www/${APPID}-docs
    networks:
      - angkor-network

# Networks can be created by specifying the network name under a top-level networks section.
# Services can connect to networks by specifying the network name under the service networks subsection
networks:
  angkor-network:

